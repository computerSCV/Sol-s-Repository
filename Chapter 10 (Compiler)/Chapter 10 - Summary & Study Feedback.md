## Chapter 10 - Contents Summary & Study Feedback  (20.05.18)



Chapter 9 는 교재에서 다룰 고수준 객체지향 언어인 Jack을 이것저것 다루는 챕터로, 

이미 Java를 다루는 내가 Java와 교재에서만 나오는 비슷한 언어(거의 유사하다)를 익힐 필요는 없다고 생각했다.

그래서 바로 Chapter 10 - 컴파일러 단원으로 넘어갔다.

우리는 Chapter 7,8 에서 VM언어를 다루어 본 경험이 있다.

VM언어는 java의 .class파일과 마찬가지로 '중간언어'라고 할 수 있는데,

컴파일러는 이 중간언어를 컴퓨터가 비로소 이해할 수 있는 언어로 바꾸는 작업을 한다.

Chapter 10과 chapter11은 이 컴파일러를 직접 만들어보는 단계인데, 

그 중 Chpater 10은 **고수준언어를 구문분석**하는 단계이며,

Chapter 11은 **구문분석한 언어를 VM코드로 변환**하는 단계이다.

즉 컴파일러는

​	**1) 고수준 언어 구문분석 (Chapter 10)**

​	**2) 각 구문을 VM코드로 변환 (Chapter 11)**

​	**3) VM코드를 어셈블리어로 변환 (Chater 7, 8)**

​	**4) 어셈블리어가 기계어(2진수)로 변환 (Chapter 6)**

이라는 각 단계를 거친다고 할 수 있을 것이다(어셈블러와 컴파일러가 분리된다고 생각할 수도 있다. 컴파일러가 더 포괄적).



---

#### 1. 구문 분석 - 토큰화

컴파일은 **원본언어에서 대상언어로 프로그램을 번역**하는 프로그램이다.

이를 위해서는 우선 원본언어의 구문을 **분석**해야 한다. 교재에서는 컴파일러가 원본언어를 '이해'한다는 것을 보여주기 위해,

입력 프로그램의 '구조'를 XML 파일로 하여 출력하는 방식을 선택했다.

구문 분석 작업, 즉 XML파일로 입력파일의 구조를 출력하는 방식은 두 가지 단계로 이루어진다. 토큰화와 파싱이 그것이다.

토큰화는 즉 **어휘분석**의 결과물이다.

코드의 가장 기본적인, 가장 단순한 구성 Component는 텍스트 토큰들이다. 가령,

```
class Test {
	int x;
	
	public Test(int x){
		this.x = x;
	}
}
```

위 코드가 있을때, 각 토큰은 아래와 같다.

```
class
Test
{
int
x
;
public
Test
(
int
x
)
{
this
.
x
=
x
;
}
}
```

즉 토큰화는 구문을 가장 작은 최소단위로 나누는 작업이다.

이렇게 토큰화가 이루어지고나면, 각 토큰은 특정 기준을 통해 분류되어질 수 있다.

class는 클래스 생성 기호, int는 변수타입...과 같은 식이다. 그리고 이 규칙은 언어가 무엇인지에 따라 다르다.

Java는 ++라는 연산자를 +1로 인식할 것이나, Python은 ++를 인식하지 못할 것이다.





#### 2. 구문 분석 - Parsing

토큰 스트림이 완성되었다면, 각 토큰들을 미리 정의된 규칙에 따라 재귀적으로 분해해나가는 작업을 해야한다.

토큰은 단말(Terminal)이라고 부르기도 하는데, Terminal로 이루어진 특정 구문은 Non-terminal(비단말)이다.

즉, if라는 토큰이 있을 때, if의 뒤 ( ) 에 들어가는 단말들을 **비단말**이라고 할 수 있다.

그럼 우리는 이 비단말을 또 다시 특정 규칙을 통해 재귀적으로 단말 요소로 분해해나갈 수 있다.

```
if(x == 1){
	y++;
}

-> 파싱 결과 : 

if(statement){
	statement;
}
```

여기서 statement가 Non-terminal을 의미하는데, 하나의 statement는 또 다른 statement들로 이루어질 수 있다.

statement는 더 이상 분해되지 않는 Terminal로 될 때까지 재귀적으로 계속 분해된다. 

따라서 구문분석 과정은 **트리구조**와 같은 형태를 띈다.



#### 3. 구현

우리가 할 일은 두 가지이다.

코드 내 주석기호 및 공백을 제외한 요소를 토큰으로 분해하는 과정과,

각 Statement에 매칭되는 메소드를 구현하여 Statement를 재귀적으로 분해해나가는 과정이 필요하다.

각각의 과정은 **JackTokenizer**와 **CompilationEngine**이라는 두 가지 모듈로 나누어 구현될 것이며, 

구현 결과는 깃헙 src에 따로 올려놓았다.



#### 4. Project 스터디 피드백

사실 해당 챕터는 6월에 시작했다가, 몇 달의 공백기를 가지고 4달 후인 10월에 완료되었다.

그 동안 다른 일들로 바쁘기도 했지만, 어려운 내용을 다루다 보니 조금 스트레스를 받아 중간에 조금 휴식기를 가진 이유가 크다.

그래도 어쨌든 수많은 디버깅 후에 구현을 완료하여 뿌듯하다.

Chapter 10의 내용 자체는 **재귀**를 이해하면 크게 어려운 점이 없었지만,

구현이 정말...노가다였다.

그래도 이제 챕터를 단 두 개만 앞두고 있는 상황이다.

올해 안에 이 컴퓨터 구조 프로젝트를 잘 마무리하고 얼른 운영체제를 공부하고싶다.